# Go_Generics

[Tutorial: Getting started with generics](https://go.dev/doc/tutorial/generics)

## non-generic functions

ここでは `int64` と `float64` の 2 つの関数を追加してジェネリクスを見ていく。

## generic function to handle multiple types

このセクションでは、整数値または浮動小数点値のマップを受け取ることができる単一のジェネリック関数を追加し、先に作成した 2 つの関数を一つの関数に効果的に置き換えます。

いずれかのタイプの値をサポートするには、その単一の関数でサポートするタイプを宣言する方法が必要になります。一方、呼び出しコードには、整数マップと浮動小数点マップのどちらで呼び出すかを指定する方法が必要です。

これをサポートするために、通常の関数パラメーターに加えて ***型パラメーター*** を宣言する関数を作成します。これらの型パラメーターにより、関数はジェネリックになりさまざまな型の引数を処理できるようになります。***型引数*** と通常の関数引数を使用して関数を呼び出します。

各型パラメーターには、型パラメーターの一種のメタ型として機能する ***型制約*** があります。各型制約は、呼び出し元のコードがそれぞれの型パラメーターに使用できる許容型引数を指定します。

型パラメーターの制約は通常、型のセットを表しますが、コンパイル時に、型パラメーターは単一の型つまり呼び出し元のコードによって型引数として提供される型を表します。型引数の型が型パラメーターの制約で許可されていない場合、コードはコンパイルされません。

タイプパラメータは、ジェネリックコードが実行するすべての操作をサポートする必要があることに注意してください。たとえば、関数のコードが制約に数値型が含まれている型パラメーターに対して `string` 操作（インデックス作成など）を実行しようとした場合、コードはコンパイルされません。

これから作成するコードでは、整数型または浮動小数点型のいずれかを許可する制約を使用します。

- `comparable` 定数は Go の中で事前に宣言された定数で、比較操作 `==` や `=!` が利用できるすべての型です。

## Remove type arguments when calling the generic function

Goコンパイラが使用する型を推測できる場合は、コードの呼び出しで型引数を省略できます。コンパイラは、関数の引数の型から型引数を推測します。

[?:具体例] これが常に可能であるとは限らないことに注意してください。たとえば、引数のないジェネリック関数を呼び出す必要がある場合は、関数呼び出しに型引数を含める必要があります。

## Declare a type constraint

この最後のセクションでは、前に定義した制約を独自のインターフェースに移動して、複数の場所で再利用できるようにします。この方法で制約を宣言すると、制約がより複雑な場合など、コードを合理化するのに役立ちます。

***型制約*** をインターフェースとして宣言します。制約により、インターフェイスを実装するすべてのタイプが許可されます。たとえば、3つのメソッドを使用して型制約インターフェイスを宣言し、それをジェネリック関数の型パラメーターとともに使用する場合、関数の呼び出しに使用される型引数には、これらのメソッドがすべて含まれている必要があります。

